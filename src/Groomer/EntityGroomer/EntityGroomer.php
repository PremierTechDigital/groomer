<?php

namespace Drupal\groomer\Groomer\EntityGroomer;

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\field\FieldConfigInterface;
use Drupal\groomer\Constants\GroomerConfig;
use Drupal\groomer\Groomer\EntityGroomer\EntityFieldGroomer\EntityFieldGroomerFactory;
use Drupal\groomer\Groomer\Groomer;
use Drupal\groomer\Service\GroomerManager;

/**
 * Groomer for a given entity.
 *
 * This object is used to return clean field data from an Entity.
 *
 * @property GroomerManager $groomerManager
 *
 * @package Drupal\groomer\Groomer\EntityGroomer
 */
class EntityGroomer extends Groomer implements EntityGroomerInterface {

  /**
   * Entity attached to the Groomer.
   *
   * @var \Drupal\Core\Entity\ContentEntityInterface
   */
  protected $entity;

  /**
   * Contains the Entity Type Id.
   *
   * Examples: Node, Paragraph, Media.
   *
   * @var string
   */
  protected $entityTypeId;

  /**
   * Contains the Entity Bundle, if any.
   *
   * Examples: basic_page, basic_paragraph, etc.
   *
   * @var string
   */
  protected $entityBundle;

  /**
   * Array to store configurations for entities loaded from the site.
   *
   * @var array
   */
  protected $configurations;

  /**
   * Parent EntityGroomer that called this groomer.
   *
   * If a groomer is called in the field of an existing groomer, then it is
   * considered the child of the existing groomer. This allows us to define
   * the depth at which at object is being groomed.
   *
   * @var \Drupal\groomer\Groomer\EntityGroomer\EntityGroomerInterface
   */
  protected $parentEntityGroomer;

  /**
   * Entity Groomer base constructor.
   *
   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
   *   The entity being groomed.
   * @param \Drupal\groomer\Service\GroomerManager $groomerManager
   *   Groomer Manager service containing Drupal services.
   * @param string $type
   *   The type of groomer defined by a string key.
   * @param string $signature
   *   The signature of the groomer generated by the factory.
   */
  public function __construct(
    ContentEntityInterface $entity,
    GroomerManager $groomerManager,
    string $type,
    string $signature) {

    parent::__construct($entity, $groomerManager, $type, $signature);

    $this->entity = $groomerManager->helpers->ensureTranslated($entity);
    $this->entityTypeId = $entity->getEntityType()->id();
    $this->entityBundle = $entity->bundle();
    $this->configurations = $this->getRelevantConfigurations();
  }

  /**
   * Get Entity Type ID for this Groomer.
   *
   * @return string
   *   Return Entity Type ID string.
   */
  public function getEntityTypeId() : string {
    return $this->entityTypeId;
  }

  /**
   * Get Entity Bundle for this Groomer.
   *
   * @return string
   *   Return Entity Bundle string.
   */
  public function getEntityBundle() : string {
    return $this->entityBundle;
  }

  /**
   * Get Entity for this Groomer.
   *
   * @return \Drupal\Core\Entity\ContentEntityInterface
   *   Return Entity.
   */
  public function getEntity() : ContentEntityInterface {
    return $this->entity;
  }

  /**
   * {@inheritdoc}
   */
  public function getParentEntityGroomer() : ?EntityGroomerInterface {
    return $this->parentEntityGroomer;
  }

  /**
   * {@inheritdoc}
   */
  public function setParentEntityGroomer(EntityGroomerInterface $groomer) : void {
    $this->parentEntityGroomer = $groomer;
  }

  /**
   * {@inheritdoc}
   */
  protected function getGroomedData() {
    // Data array that will be returned.
    $data = [];

    $field_configs = $this->groomerManager->helpers->getEntityTypeBundleFieldDefinitions($this->getEntityTypeId(), $this->getEntityBundle());

    // Process all fields for the given entity.
    /* @var integer $key */
    /* @var \Drupal\field\FieldConfigInterface $field_config */
    foreach ($field_configs as $key => $field_config) {

      // If there are any custom filtering settings for this entity...
      $field_name = $field_config->getName();

      // If this field is configured to be excluded, skip it in this loop.
      if ($this->fieldIsExcluded($field_name)) {
        continue;
      }

      // Remove "field_" prefix if we have to.
      if ($this->groomerManager->config[GroomerConfig::REMOVE_FIELD_UNDERSCORE_PREFIX] === 1) {
        $groomed_field_key = \str_replace('field_', '', $field_name);
      }
      else {
        $groomed_field_key = $field_name;
      }

      // Get the field data using the groomer.
      $groomed_field_data = $this->getGroomedFieldData($field_config);

      // Set our field data to the array.
      $data[$groomed_field_key] = $groomed_field_data;
    }

    return $data;
  }

  /**
   * Groom the given Field and return the appropriate data.
   *
   * @param \Drupal\field\FieldConfigInterface $field_config
   *   Field Definition of the field being groomed.
   *
   * @return mixed
   *   Return the field data in a proper, uniform format.
   */
  public function getGroomedFieldData(FieldConfigInterface $field_config) {
    // Get the name of the field.
    $field_name = $field_config->getName();

    // Get the field data of the entity's field.
    $entity_field_data = $this->getEntity()->get($field_name);

    // If the data is empty, return null.
    // @todo - You can manage this in each EntityFieldGroomer by checking if the field is empty there instead.
    // @todo - This will give more flexibility as it will allow to send different empty values depending on the field.
    if ($entity_field_data->isEmpty()) {
      return [];
    }

    // Build field groomer.
    /* @var \Drupal\groomer\Groomer\EntityGroomer\EntityFieldGroomer\EntityFieldGroomer $field_groomer */
    $field_groomer = EntityFieldGroomerFactory::build($entity_field_data, $this->groomerManager);

    // Groom the field data using the Groomer Manager.
    return $field_groomer->groom();
  }

  /**
   * Check if the given field is excluded for grooming.
   *
   * @param string $field_name
   *   Name of the field to check.
   *
   * @return bool
   *   Returns true if the field is excluded. Returns false otherwise.
   */
  private function fieldIsExcluded(string $field_name): bool {

    // Not excluded if configurations for this entity type do not exist.
    if (!isset($this->configurations[GroomerConfig::ENTITY_TYPE_EXCLUDED_FIELDS])) {
      return FALSE;
    }

    // Not excluded if configurations for this field do not exist.
    $entity_type_exclusion_config_exists = isset($this->configurations[GroomerConfig::ENTITY_TYPE_EXCLUDED_FIELDS][$field_name]);
    if ($entity_type_exclusion_config_exists) {
      $field_excluded_in_entity_type_exclusion_config = ($this->configurations[GroomerConfig::ENTITY_TYPE_EXCLUDED_FIELDS][$field_name] !== 0);
      if ($field_excluded_in_entity_type_exclusion_config) {
        return TRUE;
      }
    }

    // Check if bundle configurations exist and exclude this field.
    $entity_type_bundle_exclusion_config_exists = isset($this->configurations[$this->getEntityBundle()][GroomerConfig::ENTITY_TYPE_BUNDLE_EXCLUDED_FIELDS][$field_name]);
    if ($entity_type_bundle_exclusion_config_exists) {
      $field_excluded_in_entity_type_bundle_exclusion_config = ($this->configurations[$this->getEntityBundle()][GroomerConfig::ENTITY_TYPE_BUNDLE_EXCLUDED_FIELDS][$field_name] !== 0);
      if ($field_excluded_in_entity_type_bundle_exclusion_config) {
        return TRUE;
      }
    }

    // If all checks fail, return false.
    return FALSE;
  }

  /**
   * Get custom groomer configurations for this groomer.
   *
   * This will return which fields are configured to be groomed.
   *
   * @return array
   *   Array containing configuration values for this entity.
   */
  private function getRelevantConfigurations() : ?array {
    $config = \Drupal::config(GroomerConfig::CONFIG_NAME)->get(
      GroomerConfig::ENTITY_TYPE_SETTINGS
    );

    return $config[$this->getEntityTypeId()];
  }

}
